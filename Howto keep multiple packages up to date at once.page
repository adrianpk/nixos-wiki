    {pkgs, ...}:{

      packageOverrides = {
        myHaskellCollection = pkgs.misc.collection {
           name = "my-haskell-collection";
           list = let p = pkgs.haskellPackages_select_a_version;
                  in list [ p.ghc p.filepath p.XXX p.YYY ];
        };

        all = pkgs.misc.collection {
           name = "all";
           list = [ pkgs.myHaskellCollection pkgs.mutt pkgs.firefox35Wrapper /* ... */ ];
        }

      };

    }

Now you can update ghc and its libraries using

    nix-env -iA myHaskellCollection

or

    nix-env -i my-haskell-collection

The all attribute name illustrates that you can reuse your new
collection in yet another collection. Keeping such a big collection
containing all important packages which you use everyday makes it easy
to upgrade or move your setup to another pc.

**Question**: This approach does not detect file collisions. When I
install the expression

        haskellStuff = pkgs.misc.collection {
           name = "my-haskell-packages";
           list = (with pkgs.haskellPackages_ghc704; [ghc]) ++
                  (with pkgs.haskellPackages_ghc721; [ghc])Â ;
        };always
       

then I end up have both packages in one profile even though they collide
in several binaries, i.e. "ghc", "runhaskell", etc. This seems to be a
bit of a problem?

