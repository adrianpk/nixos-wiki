State of nixpkgs
----------------

The [stdenv-updates
branch](https://github.com/NixOS/nixpkgs/tree/stdenv-updates) at
[ea6b1d808c559](https://github.com/NixOS/nixpkgs/commit/ea6b1d808c55954e7446f469b976d258165c8632)
can bootstrap properly an armhf nixpkgs for the raspberrypi.

State of NixOS
--------------

NixOS [master](https://github.com/viric/nixos/tree/master) can prepare a
proper bootloader (vfat at /boot).

Having the SD vfat that the dumb loader will read at /boot, this is an
example configuration.nix:

    {pkgs, config, ...}:

    {
      boot.loader.grub.enable = false;
      boot.loader.generationsDir.enable = false;
      boot.loader.raspberryPi.enable = true;
      boot.kernelPackages = pkgs.linuxPackages_3_6_rpi;
      boot.kernelParams = [
        "coherent_pool=6M"
        "smsc95xx.turbo_mode=N"
        "dwc_otg.lpm_enable=0"
        "root=/dev/sda5"
        "rootwait"
        "console=tty1"
        "elevator=deadline"
      ];

      # cpufrequtils doesn't build on ARM
      powerManagement = false;

      fileSystems = [
        {
          device = "/dev/mmcblk0p1";
          mountPoint = "/boot";
          fsType = "vfat";
        }
        {
          device = "/dev/sda5";
          mountPoint = "/";
          fsType = "ext4";
        }
      ];

      services.xserver.enable = false;
      services.openssh = {
        enable = true;
        permitRootLogin = "yes";
      }; 
    }

Using distcc
------------

The Raspberry Pi compiles things very slowly. You can help it with the
new feature of stdenv-updates stdenv: *userHook*. You have to set it up
to introduce an impurity in your nixpkgs like this:

    {
      stdenv.userHook = "test -f /niximpure/impure.sh && . /niximpure/impure.sh";
    }

In case you build nixos, remember to set the userHook also in nixos'
nixpkgs.config.

The `impure.sh` script will be in charge of loading *distcc*. A
simplification of what I use:

    case $out in
      *)
         case $NIX_GCC in
           *-gcc-wrapper-4.7* | *-bootstrap-gcc-wrapper*)
             echo Using distcc for gcc 4.7
             export DISTCC_HOSTS=192.168.1.35
             PATH=/niximpure/distcc:$PATH
             export HOME=/niximpure/home
             ;;
           *-gcc-wrapper-4.6*)
             echo Using distcc for gcc 4.6
             export DISTCC_HOSTS=192.168.1.35:3633
             PATH=/niximpure/distcc:$PATH
             export HOME=/niximpure/home
             ;;
         esac
       ;;
    esac

The /niximpure tree looks like this. Notice `/usr/bin/distcc`; it can
point at any distcc you have working, be it in /usr or one nix-built. It
will call the next gcc in PATH in the builds, not using /usr/bin/gcc.

    # ls -lR /niximpure
    /niximpure:
    total 16
    drwxr-xr-x 2 root root 4096 28 des 00:06 distcc
    drwxrwxr-x 4 root 1002 4096  4 gen 14:32 home
    -rw-r--r-- 1 root root 1351 26 gen 13:06 impure.sh
    drwxr-xr-x 3 root root 4096 29 des 18:57 pump

    /niximpure/distcc:
    total 0
    lrwxrwxrwx 1 root root 15 23 des 21:09 c++ -> /usr/bin/distcc
    lrwxrwxrwx 1 root root 15 23 des 21:08 cc -> /usr/bin/distcc
    lrwxrwxrwx 1 root root 15 23 des 21:08 g++ -> /usr/bin/distcc
    lrwxrwxrwx 1 root root 15 23 des 21:08 gcc -> /usr/bin/distcc

    /niximpure/home:
    total 0

### Server side

Having a copy of stdenv-updates nixpkgs, you can build your
cross-compilers for distcc. Prepare a directory for them:

    mkdir distcc
    cd distcc

And create a nix file (`pi.nix`) for example there with these contents:

    let
      pkgsFun = import <nixpkgs>;
      pkgsNoParams = pkgsFun {};
    in
    pkgsFun
    {
       crossSystem = {
           config = "armv6l-unknown-linux-gnueabi";
           bigEndian = false;
           arch = "arm";
           float = "hard";
           fpu = "vfp";
           withTLS = true;
           libc = "glibc";
           platform = pkgsNoParams.platforms.raspberrypi;
           openssl.system = "linux-generic32";
           gcc = {
             arch = "armv6";
             fpu = "vfp";
             float = "hard";
             abi = "aapcs-linux";
           };
       };

       config = pkgs: {
         packageOverrides = pkgs : {
           platform = pkgs.platforms.sheevaplug;
           distccMasquerade = pkgs.distccMasquerade.override {
             gccRaw = pkgs.gccCrossStageFinal.gcc;
             binutils = pkgs.binutilsCross;
           };
         };
         kernel.extraConfig = 
           IPV6 y
           BLK_DEV_LOOP y
         ;
       };
    }

In case `gcc_realCross = gcc47_realCross`, you can build the gcc 4.7
cross-compiler this way. The gcc 4.7 compiler is the compiler in the
bootstrap-tools to build the stdenv.

    nix-build -o pi-gcc47 distccMasquerade pi.nix

You can then start distcc serving this, having distcc installed, and
running:

    PATH=`pwd`/pi-gcc47/bin:$PATH distccd --allow 192.168.1.0/24 --stats --stats-port 8032

Once stdenv is built, as it includes gcc 4.6, you will need the
cross-compiler gcc 4.6, which you can build using the same technique as
before, but changing `gcc_realCross = gcc46_realCross` in nixpkgs'
`all-packages.nix`.

