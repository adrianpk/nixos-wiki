Example Case
------------

Many software developers use an IDE to edit source code. In this
tutorial, we will discuss using the [KDevelop
IDE](http://www.kdevelop.org) to develop an application. This
application is built by using a standard compiler, CMake, and QT, and it
is managed using Git. So, to get started developing this application, we
need to install these tools in our environment.

Unlike other Linux or Unix systems, a normal NixOS instance has none of
these tools. What does this mean? If a NixOS user types `make` in a
normal terminal, an error will be displayed which says a program named
"make" does not exist.

So, how can we use Nix to obtain an environment which contains all tools
required to work on a project?

Two solutions: A) Rely on app's package B) Manually define build
environment

### A) Rely on Nix Package

A Nix package declares everything required to build the packaged code.
Therefore, if we want to work on the packaged app, we can ask the
package manager to set up the tools for us. Normally, when Nix builds a
package, it builds it in an isolated environment. It does this by
creating a child shell, clearing it to a blank slate, then adding only
the dependencies the package declares. After setting up the
dependencies, it runs the build script, moves the built app into the Nix
store, and sets up the environment to point to it. Finally, it destroys
this child shell.

We want to iteratively modify and build the packaged app. Can we ask Nix
to \`\`\`not\`\`\` destroy the child shell, and instead let us use it
for working on the app? Yes we can. A Nix command was created for
exactly this use-case - the `nix-shell` command. To work on the `nvi`
app, which is a Nix-packaged app, use the following command to set up
all build tools in a child shell.

     nix-shell [--command /bin/sh] nvi

 Additional info:
<https://github.com/NixOS/nix/commit/7f38087f35e6f74a73bfdb28da8acd8930565d51>

### B) Manually Define Build Environment

The first solution, to rely on the Nix package, will give us a single
shell which can build the app, which is a very useful tool. Sometimes,
however, we want to use the entire OS as a development environment,
rather than a single shell. This implies that every new shell, as well
as every application we launch from the desktop, will be able to build
the app. How can we do this?

If we answer this question in the context of NixOS, we are asking about
the "User Environment", which is a set of "active" applications.
Remember, a user can install many applications using Nix, but they are
all hidden in the Nix store behind hash-named directories. To use these
applications, they must be made visible to a shell by adding these
applications to the `PATH` environment variable. The implementation is
rather complicated, but the key idea is that Nix manages which of its
applications are visible. This set of applications is called a "User
Environment".

#### Managing User Environments with myEnvFun

So, our goal is to create a User Environment which contains all required
tools to edit a Nix-packaged app. How do we create this User
Environment? An app was created which helps us define a custom User
Environment and then switch to it. This package is called `myEnvFun`.

How do we use `myEnvFun`? Currently, it requires a bit of setup. The
documentation for this setup exists in the [`myEnvFun` source
code](https://github.com/NixOS/nixpkgs/blob/master/pkgs/misc/my-env/default.nix).

The `nixpkgs/pkgs/misc/my-env/default.nix` Nix expression is intended to
be used by a normal user. Just open the mentioned file with the text
editor of choice and look at the comments (which should be very similar
to the contents of this Wiki page), so read on.

### a simple example \~/.nixpkgs/config.nix

this file contains the user configuration for one or more custom
environments. let's create it:

     $ mkdir ~/.nixpkgs

ensure that the config.nix contains something like:

     $ cat config.nix
     {
       packageOverrides = pkgsÂ : with pkgs; {
         sdlEnv = pkgs.myEnvFun {
             name = "sdl";
             buildInputs = [ stdenv SDL SDL_image SDL_ttf SDL_gfx cmake SDL_net pkgconfig ];
         };
       };
     }

by following the installation procedure of our new custom environment,
also found in /etc/nixos/nixpkgs/pkgs/misc/my-env/default.nix, one can
extend his standard environment by the desired new environment.

     $ nix-env -i env-sdl

using this new environment:

     $ load-env-sdl

to verify that the new environment got all tools needed, type:

     $ make

and verify that the tool is there.

### how to use that environment

after the new environment has loaded you can use the tools as if you
were on ubuntu or debian linux where all the tools are available
throughout the whole system once they have been installed. note that on
other shells you won't have these tools, so you also have to change the
environment if you want them to have the tools as well.

loading the environment

     [joachim@eliteBook-8530w:~/Desktop/projects]$ load-env-sdl
     env-sdl loaded

using sdl-config to get the cflags

     sdl:[joachim@eliteBook-8530w:~/Desktop/projects]$ sdl-config --cflags
     -I/nix/store/652x8hnhja32z3ja4hip04ygn8mh9cwi-SDL-1.2.14/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT

using sdl-config to get the library postition

     sdl:[joachim@eliteBook-8530w:~/Desktop/projects]$ sdl-config --libs
     -L/nix/store/652x8hnhja32z3ja4hip04ygn8mh9cwi-SDL-1.2.14/lib -Wl,-rpath,/nix/store/652x8hnhja32z3ja4hip04ygn8mh9cwi-SDL-1.2.14/lib -lSDL -lpthread

in the `Makefile` of your sdl using project you usually call sdl-config
to get these values and paths.

**note: the exact path might differ from mine as you might have a
different hash**

### another example

<http://invalidmagic.wordpress.com/2012/03/23/developing-software-using-nixos/>

other related topics
--------------------

### how to use libraries which don't have a sdl-config or don't use pkgconfig

when you load `load-env-sdl` there will be some additional environment
variables set:

-   CMAKE\_PREFIX\_PATH
-   NIX\_CFLAGS\_COMPILE
-   NIX\_LDFLAGS

all these variables contain include paths and ldflags used by the
compiler.

**note: the load-env-sdl using sdl is just an example here, however the
mentioned environment variables can be used for various libraries which
don't even use sdl-config like tools.**

**note: once these paths are set correctly (caused by the
load-env-whateverYourEnvironmentIsCalled command) you would not depend
on tools like sdl-config or pkgconfig. this helps to get libraries
working which don't use these kind of tools to make them accessible.**

### code completion in kdevelop

kdevelop has code completion but it requires the source of the used
libraries of course. On NixOS these libraries however reside in the
/nix/store and are therefore more or less very strange compared to other
distributions.

To have full code completion in kdevelop you need this procedure:

1.  rm -Rf myCustomProject/build/\*
2.  load-env-sdl (where the project would use cmake)
3.  start 'kdevelop' from that shell
4.  import the CMakeLists.txt of the project
5.  kdevelop asks where to build the project -\> chose the default
    myCustomProject/build
6.  build the selection
7.  afterwards there should be code completion for the whole project

What might not work is that you can open several projects in this
kdevelop session. But that should be a minor issue i guess.

sample development environments
-------------------------------

### Python development environment

       {
         # Define a myEnvFun environment, which makes use of pythonPlone
         packageOverrides = pkgs: rec {
        
           # Define a version of python which has access to all the Plone modules
           pythonPlone = pkgs.pythonFull.override {
             extraLibs = with pkgs.python27Packages; [ Plone ];
           };
        
           plone = pkgs.myEnvFun {
             name = "plone";
             buildInputs = with pkgs; [
               pythonPlone
               python27Packages.zc_buildout_nix
               stdenv # provides gcc for building python c extensions
            ];
            # Export the path to the custom version of python with all the goodies
            # Other python command line utilies could also be used, e.g. IPython
            extraCmds = 
              export PYTHONHOME=${pythonPlone}
              unset http_proxy # otherwise downloads will fail ("nodtd.invalid")
            ;
           };
        
         };
       }

summary
-------

it is easy to add several different environments to
`~/.nixpkgs/config.nix` and these can then be used, one at a time, for
development. one can exit from such an environment using `CTRL+D` or
simply by typing `exit` as it is realized as a sub-shell (similar to
typing bash inside a shell).

the main benefit is that you do not pollute your main profile with
development tools and that you can use several different versions of a
library on the same system (main nix advantage) but accessible from
within different environments.

