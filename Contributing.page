A more elaborate guide can be found here [Contributing to
nixpkgs](//Contributing to nixpkgs).

Getting started
---------------

See the official documentation which describes how the Nix expression
language works so that you can update existing packages and add new
ones.

-   [Nix
    manual](http://hydra.nixos.org/job/nix/trunk/tarball/latest/download-by-type/doc/manual)
-   [Nixpkgs
    manual](http://hydra.nixos.org/job/nixpkgs/trunk/tarball/latest/download-by-type/doc/manual),
    in particular [Coding
    conventions](http://hydra.nixos.org/job/nixpkgs/trunk/tarball/latest/download-by-type/doc/manual#chap-conventions)
-   [NixOS
    manual](http://hydra.nixos.org/job/nixos/trunk/manual/latest/download)

I have a patch
--------------

Thanks. Open a [pull request](//Pull request) on github.

If your change breaks things don't scream if someone reverts it. It
happens. The best thing to do is to fix your patch. Try to check first
if it will cause a lot of rebuilds and add a note to your pull request
if you have already tested everything.

what meta attributes are important
----------------------------------

-   \*meta.platforms\* will tell hydra to build binaries for specific
    platform targets. By default hydra doesn't build anything.

-   \*meta.maintainers\* will tell hydra what emails to send when a
    build fails

-   \*meta.license\* will tell hydra how to handle package based on
    license type

Example:

    meta = with stdenv.lib; {
      description = "Munin is a networked resource monitoring tool that can help analyze resource trends";
      homepage = http://munin-monitoring.org/;
      license = licenses.gpl2;
      maintainers = [ maintainers.iElectric ];
      platforms = platforms.linux;
    };

check if there are any evaluation errors with your distribution
---------------------------------------------------------------

    nix-instantiate --eval-only --strict --xml -A <packagename>

How to verify that you didn't break a dependency or the evaluation by accidentÂ ?
--------------------------------------------------------------------------------

To find out which packages are effected by your change:

    $ nix-env -f . -qaP \* --drv-path | sort > l1
    (...modify package...)
    $ nix-env -f . -qaP \* --drv-path | sort > l2
    $ changed=$(diff l1 l2 | awk '{print $2}' | sort | uniq)

    # This list can be used to create a release.nix for testing, or you can build all the relevant packages:
    $ nix-build $(for i in $changed; do echo -A $i; done)

    #!/bin/sh
    set -e -x

    export NIXOS=${NIXOS:-/etc/nixos/nixos}
    export NIXPKGS_ALL=${NIXPKGS_ALL:-/etc/nixos/nixpkgs}

    # evaluate all derivations found in all-packages.nix:
    nix-env -qa '*' --show-trace -P --out-path -f $NIXPKGS_ALL/pkgs/top-level/all-packages.nix

    # evaluate all derivations found in release.nix before starting the build:
    # nix-env -qa '*' $NIXPKGS_ALL/pkgs/top-level/release.nix
    # nix-instantiate --readonly-mode $NIXPKGS_ALL/pkgs/top-level/release.nix --show-trace

    # build a release tarball which contains the most important packages (?)
    nix-build -A tarball $NIXOS/release.nix --show-trace

TODO: explain what is done exactly

 The nixpkgs-dev-utilities referenced on [Nix(OS) related repositories
and work](//Nix(OS) related repositories and work) tries to implement
this for your convinience

merging git pull requests
-------------------------

hitting the "merge" button on github is fine, however doing

       curl 'patch url' | git am; git push

is finer, because history will be cleaner.

