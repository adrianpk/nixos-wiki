this wiki page describes **how to work with nixos/nixpkgs/...**:

     https://github.com/nixos

basics
------

say you are running nixos using nixpkgs and you want to make a change,
update a package, add a new package etc. First you need to clone the
NixOS repositories:

     $ mkdir -p nixrepos
     $ cd nixrepos
     $ git clone https://github.com/NixOS/nixpkgs
     $ git clone https://github.com/NixOS/nixos

Now you have two local repositories: nixpkgs and nixos

Our workflow is similar to the diaspora documented one, so have a
glimpse there as well:

     https://github.com/diaspora/diaspora/wiki/Git-Workflow

how to install from the local repository
----------------------------------------

this section tells you how to apply changes to your current system based
on your local repositories:

**first do this**

     $ export NIXREPOS=/some/path/nixrepos # example: export NIXREPOS=/home/user/nixrepos

**example: list all available software** from the local repository
\$NIXREPOS/nixpkgs

     $ NIX_PATH="nixos=$NIXREPOS/nixpkgs" nix-env -f '<nixos>' -qa '*'

**example: install software from local repository**

     $ NIX_PATH="nixos=$NIXREPOS/nixpkgs" nix-env -f '<nixos>' -i python-urlgrabber

**example: update the system** based on your local **\$NIXREPOS/nixos**
and **\$NIXREPOS/nixpkgs**

     $ nixos-rebuild -I nixos=$NIXREPOS/nixos -I nixpkgs=$NIXREPOS/nixpkgs switch

**example: build an expression and put the output in to
\`pwd\`/results**

     $ nix-build $NIXREPOS/nixpkgs -A irssi

**example: get an environment which is used to build irssi**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi

**example: get an persistent environment which is used to build irssi**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi --add-root

**NOTE:** it would be awesome if there was a bash/zsh extension which
would export NIX\_PATH=$NIXREPOS, when entering the directory $NIXREPOS/
in a shell.

git
---

### git rebase

     git pull upstream master

now after some modifications ...

     git add foo
     git commit
     git fetch upstream master
     git pull --rebase upstream master
     git push upstream

### theory: keeping in sync with hydra builds

problem: if you use a local git checkout of nixos/nixpkgs's **upstream
master** to develop software with, you might end up in compiling a lot
when doing: **nixos-rebuild switch**. this happens for example when
there is a fundamental change which requires a lot of packages to be
rebuilt. It is even likely that you hit bugs/issues which are caused by
someone else.

Ideally **you want to change the state of your current system** which
means that **you will not work on upstream/master** but **on the state
of the channel** which is known to be pretty stable.

A channel is only updated if a hydra build job succeeded, that means
(compared to using a local upstream/master git checkout of
nixos/nixpkgs) if you type **nix-env -i firefox**

    * you might get an older binary substitute if the hydra build of the new expression hasn't finished yet
    * you might get an older binary substitute if the hydra build of a newer version failed

#### how does this work

run:

      nix-channel --update

then run:

      nixos-version
      0.2pre-769b74c-f430032

note: the first number (769b74) is nixos revision, the second number is
the nixpkgs (f430032) revision which is

note: requires version nix-1.6.x

then run:

      cd $NIXREPOS/nixpkgs
      git pull
      git checkout -b nixpkgschannel f430032
      nix-shell $NIXREPOS/nixpkgs  -A bc
      mkdir -p /tmp/foo/out
      cd /tmp/foo
      export out=/tmp/foo/out

also modify the configureFlags prefix:

      export configureFlags="--prefix=$out --with-readline"

now we have find out which phases we need to run:

       typeset -f genericBuild | grep 'phases='
       phases="$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases";

so when developing you need to run these phases in a row:

      patchPhase
      configurePhase
      buildPhase
      checkPhase
      installPhase
      fixPhase
      installCheckPhase
      installPhase
      distPhase

note: you do not need to run \$preConfigurePhase explicitly as it is
run, when running configurePhase already.

list all functions which are declared in **set**:

      typeset -F
      declare -f addCVars
      declare -f addToCrossEnv
      declare -f addToNativeEnv
      declare -f addToSearchPath
      declare -f addToSearchPathWithCustomDelimiter
      declare -f buildPhase
      declare -f checkPhase
      declare -f closeNest
      declare -f command_not_found_handle
      declare -f configurePhase
      declare -f distPhase
      declare -f dumpVars
      declare -f ensureDir
      declare -f exitHandler
      declare -f findInputs
      declare -f fixLibtool
      declare -f fixupPhase
      declare -f genericBuild
      declare -f header
      declare -f installBin
      declare -f installCheckPhase
      declare -f installPhase
      declare -f patchELF
      declare -f patchPhase
      declare -f patchShebangs
      declare -f runHook
      declare -f showPhaseHeader
      declare -f startNest
      declare -f stopNest
      declare -f stripDirs
      declare -f stripHash
      declare -f substitute
      declare -f substituteAll
      declare -f substituteAllInPlace
      declare -f substituteInPlace
      declare -f unpackFile
      declare -f unpackPhase

list a particular function type:

      typeset -f unpackPhase
      
      unpackPhase () 
      { 
          runHook preUnpack;
          if [ -z "$srcs" ]; then
              if [ -z "$src" ]; then
                  echo 'variable $src or $srcs should point to the source';
                  exit 1;
              fi;
              srcs="$src";
          fi;
          local dirsBefore="";
          for i in *;
          do
              if [ -d "$i" ]; then
                  dirsBefore="$dirsBefore $i ";
              fi;
          done;
          for i in $srcs;
          do
              unpackFile $i;
          done;
          if [ -n "$setSourceRoot" ]; then
              runHook setSourceRoot;
          else
              if [ -z "$sourceRoot" ]; then
                  sourceRoot=;
                  for i in *;
                  do
                      if [ -d "$i" ]; then
                          case $dirsBefore in 
                              *\ $i\ *)
      
                              ;;
                              *)
                                  if [ -n "$sourceRoot" ]; then
                                      echo "unpacker produced multiple directories";
                                      exit 1;
                                  fi;
                                  sourceRoot="$i"
                              ;;
                          esac;
                      fi;
                  done;
              fi;
          fi;
          if [ -z "$sourceRoot" ]; then
              echo "unpacker appears to have produced no directories";
              exit 1;
          fi;
          echo "source root is $sourceRoot";
          if [ "$dontMakeSourcesWritable" != 1 ]; then
              chmod -R u+w "$sourceRoot";
          fi;
          runHook postUnpack
      }

nix channels
------------

nix channels can be used in parallel with your new local repositories,
see its
[nix-channel-documentation](//Install/remove software#nix-channels)

