This article describes how to work with the nix related repositories to
add new packages, edit and debug existing packages and also how to
create and edit configuration options and services for NixOS.

The nix repositories are hosted here: <https://github.com/nixos>

Basics
------

The code for nix packages is managed in the nixpkgs repository. NixOS
services, and other system configuration options are managed in the
nixos repository.

The steps to take for your first change should look something like this:

1.  Fork the repo (e.g. click the fork button on
    <https://github.com/nixos/nixpkgs>).
2.  Clone your fork `git clone git@github.com:nixnoob/nix-ray.git`
3.  Hack hack hack
4.  Push your changes to your fork
5.  Open a pull request
6.  Profit!

This is pretty much the standard way to use github, so if you have
trouble using git or github any general guide on these should get you
going, or just ask on the NixOS IRC channel. The rest of this guide
deals with the "Hack hack hack" step :)

How to install from the local repository
----------------------------------------

For the sake of this article, let's set an environment variable which
points to the directory where we've cloned our repos.

     $ export NIXREPOS=/home/nixnoob/nixrepos

make some changes ...

**example: list all available software** from the local repository
\$NIXREPOS/nixpkgs

     $ nix-env -f $NIXREPOS/nixpkgs -qaP '*'

**example: install software from local repository**

     $ nix-env -f $NIXREPOS/nixpkgs -i python-urlgrabber

**example: update the system** based on your local **\$NIXREPOS/nixos**
and **\$NIXREPOS/nixpkgs**

     $ nixos-rebuild -I nixos=$NIXREPOS/nixos -I nixpkgs=$NIXREPOS/nixpkgs switch

**example: build an expression and put the output in to
\`pwd\`/results**

     $ nix-build $NIXREPOS/nixpkgs -A irssi

**example: get an environment which is used to build irssi (also see
nix-shell)**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi

**example: get an persistent environment which is used to build irssi**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi --add-root

Tracking upstream changes and avoiding extra rebuilding
-------------------------------------------------------

You have forked the relevant nix repository, but you will want to track
changes in the upstream nix repo too. You can add a remote, and a
corresponding branch for this.

     git remote add upstream https://github.com/NixOS/nixpkgs.git

You can create a branch to track the upstream master branch:

     git checkout -b upstream-master upstream/master
     git pull

This will put you into a branch with all the latest changes. Hydra, the
build farm, regularly creates binaries, but, since people are constantly
contributing to the nix repositories, it is usually the case that there
are changes in the master branch which have not yet made it into the
binary channel. To take advantage of available binaries you can switch
to the revision which produced the binaries in your current system and
apply your changes there. You can use \`nixos-version\` to see the
relevant short revision hash:

     $ nixos-version 
     13.07pre4871_18de9f6-3c35dae (Aardvark)

This string shows the Nixos release number (13.07pre4871) followed by
the nixos revision used to produce your current system (18de9f6)
followed by the nixpkgs revision (3c35dae).

 After making some changes you can commit them into your local repo:

     git add foo
     git commit

 And then you can merge the upstream changes into your branch

If some time has passed since you have created your fork, you will want
to merge your changes with upstream and test that it still works.

     git fetch upstream
     git merge upstream

### Take advantage of available binaries from Hydra

problem: if you use a local git checkout of nixos/nixpkgs's **upstream
master** to develop software with, you might end up in compiling a lot
when doing: **nixos-rebuild switch**. this happens for example when
there is a fundamental change which requires a lot of packages to be
rebuilt. It is even likely that you hit bugs/issues which are caused by
someone else.

Ideally **you want to change the state of your current system** which
means that **you will not work on upstream/master** but **on the state
of the channel** which is known to be pretty stable.

A channel is only updated if a hydra build job succeeded, that means
(compared to using a local upstream/master git checkout of
nixos/nixpkgs) if you type **nix-env -i firefox**

    * you might get an older binary substitute if the hydra build of the new expression hasn't finished yet
    * you might get an older binary substitute if the hydra build of a newer version failed

#### nixos-version

      nixos-version
      0.2pre-769b74c-f430032

The last strings at the end indicate the git short revision hash of
nixos and nixpkgs. The first one (769b74) is nixos revision, the second
one is the nixpkgs (f430032) revision.

      cd $NIXREPOS/nixpkgs

You can create a

      git pull
      git checkout -b nixpkgschannel f430032
      nix-shell $NIXREPOS/nixpkgs  -A bc
      mkdir -p /tmp/foo/out
      cd /tmp/foo
      export out=/tmp/foo/out

note: nix-shell requires version nix-1.6.x

also modify the configureFlags prefix:

      export configureFlags="--prefix=$out --with-readline"

now we have find out which phases we need to run:

       typeset -f genericBuild | grep 'phases='
       phases="$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases";

so when developing you need to run these phases in a row:

      unpackPhase
      patchPhase
      configurePhase
      buildPhase
      checkPhase
      installPhase
      fixPhase
      installCheckPhase
      installPhase
      distPhase

note: you do not need to run \$preConfigurePhase explicitly as it is
run, when running configurePhase already.

list all functions which are declared in **set**:

      typeset -F
      declare -f addCVars
      declare -f addToCrossEnv
      declare -f addToNativeEnv
      declare -f addToSearchPath
      declare -f addToSearchPathWithCustomDelimiter
      declare -f buildPhase
      declare -f checkPhase
      declare -f closeNest
      declare -f command_not_found_handle
      declare -f configurePhase
      declare -f distPhase
      declare -f dumpVars
      declare -f ensureDir
      declare -f exitHandler
      declare -f findInputs
      declare -f fixLibtool
      declare -f fixupPhase
      declare -f genericBuild
      declare -f header
      declare -f installBin
      declare -f installCheckPhase
      declare -f installPhase
      declare -f patchELF
      declare -f patchPhase
      declare -f patchShebangs
      declare -f runHook
      declare -f showPhaseHeader
      declare -f startNest
      declare -f stopNest
      declare -f stripDirs
      declare -f stripHash
      declare -f substitute
      declare -f substituteAll
      declare -f substituteAllInPlace
      declare -f substituteInPlace
      declare -f unpackFile
      declare -f unpackPhase

list a particular function type:

      typeset -f unpackPhase
      
      unpackPhase () 
      { 
          runHook preUnpack;
          if [ -z "$srcs" ]; then
              if [ -z "$src" ]; then
                  echo 'variable $src or $srcs should point to the source';
                  exit 1;
              fi;
              srcs="$src";
          fi;
          local dirsBefore="";
          for i in *;
          do
              if [ -d "$i" ]; then
                  dirsBefore="$dirsBefore $i ";
              fi;
          done;
          for i in $srcs;
          do
              unpackFile $i;
          done;
          if [ -n "$setSourceRoot" ]; then
              runHook setSourceRoot;
          else
              if [ -z "$sourceRoot" ]; then
                  sourceRoot=;
                  for i in *;
                  do
                      if [ -d "$i" ]; then
                          case $dirsBefore in 
                              *\ $i\ *)
      
                              ;;
                              *)
                                  if [ -n "$sourceRoot" ]; then
                                      echo "unpacker produced multiple directories";
                                      exit 1;
                                  fi;
                                  sourceRoot="$i"
                              ;;
                          esac;
                      fi;
                  done;
              fi;
          fi;
          if [ -z "$sourceRoot" ]; then
              echo "unpacker appears to have produced no directories";
              exit 1;
          fi;
          echo "source root is $sourceRoot";
          if [ "$dontMakeSourcesWritable" != 1 ]; then
              chmod -R u+w "$sourceRoot";
          fi;
          runHook postUnpack
      }

nix channels
------------

nix channels can be used in parallel with your new local repositories,
see its
[nix-channel-documentation](//Install/remove software#nix-channels)

