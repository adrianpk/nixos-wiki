This tutorial covers the major points of NixOS configuration. In this
tutorial, we configure NixOS to start an IRC client every time the OS
starts. This tutorial will start by adding this functionality to the
`configuration.nix` file. Then, this functionality is extracted into a
separate file, which NixOS calls a "module".

Example: Add a System Service
=============================

Suppose you want to start an IRC client and connect to your favorite
channel every time your NixOS starts. To do this, we will start the IRC
client using a shell command. In other distributions, to perform an
action on system start, you place the shell command in an init script,
which is usually the `/etc/init.d` file.

In NixOS, on the other hand, all system files are overwritten when the
`configuration.nix` file is updated and the system is rebuilt. How does
a NixOS user execute a shell command on system start? In NixOS, all
dependencies are clean and organized, which means they are changed in a
single place - the `configuration.nix` and the modules it loads. To
change the system's behavior, then, we must add this IRC shell command
to this configuration file.

Lets start the IRC session using `irssi` as the IRC client. We'll run it
inside a `screen` daemon, which enables the IRC session to continue even
after we log out of our shell session.

Implementations
===============

Quick Implementation
--------------------

The simplest way to implement this is to add a simple snippet of code to
the `/etc/nixos/configuration.nix` file:

    {pkgs, ...}:

    # pkgs is used to fetch screen & irssi.
     
    {
      jobs.ircSession = {
        description = "Start the irc client of username."
        startOn = "started network-interfaces";
        exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
      };

      environment.systemPackages = [ pkgs.screen ];
      security.sudo.enable = true;

      # ... usual configuration ...
    }

What does this do? The `jobs.ircSession` bit is an option which adds a
new system service. This option is defined elsewhere in the NixOS
configuration files. This is one of many options; you can see a list of
all NixOS configuration options in the [NixOS Manual: List of
Options](http://nixos.org/nixos/manual/#ch-options). We add attributes
to this option to configure our new service. As you can see, we
configure it to start when the network connects, and to execute a shell
command.

After rebuilding the NixOS configuration with this file, our IRC session
should start when our network connects. The IRC session is started as a
child to the screen daemon, which is independent of any user's session
and will continue running when we log out. To connect to the IRC
session, we SSH into the system, reconnect to the screen session, and
choose the IRC window. Here's the command:

    ssh username@my-server -t screen -d -R irc

Conditional Implementation
--------------------------

Suppose we want to share this functionality with your second computer,
which is a similar NixOS system. The computers are very similar, so we
can reuse most of the configuration file. How do we use the same
configuration file, but change behavior depending on the host system?
One way is to assume the "hostname" of each system is unique. If the
hostname is X, we enable the service, and if it is Y, we disable it.

We can use the `mkIf` function in the `configuration.nix` file to add
conditional behavior. Here's the new implementation:

    {config, pkgs, ...}:

    {
      jobs = pkgs.lib.mkIf (config.networking.hostname == "my-server") {
        ircSession = {
          description = "Start the irc client of username."
          startOn = "started network-interfaces";
          exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
        };
      };

      environment.systemPackages = pkgs.lib.mkIf (config.networking.hostname == "my-server") [ pkgs.screen ];
      security.sudo.enable = (config.networking.hostname == "my-server");

      # ... usual configuration ...
    }

This works, but if we use too many conditionals, our code will become
difficult to read and modify. For example, what do we do when we want to
change the hostname?

Modular Configuration
---------------------

To avoid using conditional expressions in our `configuration.nix` file,
we can separate these properties into units and blend them together
differently for each host. Nix allows us to do this with the `imports`
keyword (see [NixOS Manual:
Modularity](http://nixos.org/nixos/manual/#idp522432)) to separate each
concern into its own file. One way to organize this is to place common
properties in the `configuration.nix` file and move the the IRC-related
properties into an `irc-client.nix` file.

If we move the IRC stuff into the `irc-client.nix` file, we change the
`configuration.nix` file like this:

    {
      imports = [
        ./irc-client.nix
      ];

      # ... usual configuration ...
    }

The `irc-client.nix` file will, of course, look like this:

    {config, pkgs, ...}:

    pkgs.lib.mkIf (config.networking.hostname == "my-server") {
      jobs.ircSession = {
        description = "Start the irc client of username."
        startOn = "started network-interfaces";
        exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
      };

      environment.systemPackages = [ pkgs.screen ];
      security.sudo.enable = true;
    }

If we organize our configuration like this, sharing it across machines
is easier. In addition, our IRC client can be consistent across machines
that choose to use it.

Sharing Configuration
---------------------

The user has discussed his configuration on irc and some other person
wants to benefits form his modification. Thus he has to remove all parts
which are dependent on his system and make it more general. So he
decides to replace the condition and the username by options.

He modifies irc-client.nix to look like this:

    {config, pkgs, ...}:

    let
      cfg = config.services.ircClient;
    in

    with pkgs.lib;

    {
      options = {
        services.ircClient = {
          enable = mkOption {
            default = false;
            type = with types; bool;
            description = ''
              Start an irc client for a user.
            '';
          };

          user = mkOption {
            default = "username";
            type = with types; uniq string;
            description = ''
              Name of the user.
            '';
          };
        };
      };

      config = mkIf cfg.enable {
        jobs.ircSession = {
          description = "Start the irc client of ${cfg.user}."
          startOn = "started network-interfaces";
          exec = ''/var/setuid-wrappers/sudo -u ${cfg.user} -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
        };

        environment.systemPackages = [ pkgs.screen ];
        security.sudo.enable = true;
      };
    }

This module is now independent of the system and the user can modify his
`configuration.nix` to get his previous configuration.

    {config, ...}:

    {
      require = [
        ./irc-client.nix
      ];

      services.ircClient.enable = config.networking.hostname == "my-server";
      services.ircClient.user = "username";

      # ... usual configuration ...
    }

Multiple Daemons
================

The user now hosts multiple person on his server, and they want to have
the same irc client running in background. One easy possibility would be
to replace the user name by a list of user names, but this would not add
more value in this tutorial. Another solution is to extend jobs with the
irc client options. This will extend the options available inside
`jobs.<name>`.

    {config, pkgs, ...}:

    let
      anyIrcClient = with pkgs.lib;
        fold (j: v: v || j.ircClient.enable) (attrValues config.jobs);
    in

    with pkgs.lib;

    {
      options = {
        jobs.options = {config, ...}: let
          cfg = config.ircClient;
        in {
          options = {
            ircClient.enable = mkOption {
              default = false;
              type = with types; bool;
              description = ''
                Start an irc client for a user.
              '';
            };

            ircClient.user = mkOption {
              default = "username";
              type = with types; uniq string;
              description = ''
                Name of the user.
              '';
            };
          };

          config = mkIf cfg.enable {
            description = "Start the irc client of ${cfg.user}."
            startOn = "started network-interfaces";
            exec = ''/var/setuid-wrappers/sudo -u ${cfg.user} -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
          };
        };
      };

      config = mkIf anyIrcClient {
        environment.systemPackages = [ pkgs.screen ];
        security.sudo.enable = true;
      };
    }

Test your modules in a Virtual Machine with build-vm
====================================================

To test your new service in a VM create a file e.g. my-new-service.nix:

    {config, pkgs, ...}:
    {
      # You need to configure a root filesytem
      fileSystems."/".label = "vmdisk";

      # The test vm name is based on the hostname, so it's nice to set one
      networking.hostName = "vmhost"; 

      # Add a test user who can sudo to the root account for debugging
      users.extraUsers.vm = {
        password = "vm";
        shell = "${pkgs.bash}/bin/bash";
        group = "wheel";
      };
      security.sudo = {
        enable = true;
        wheelNeedsPassword = false;
      };

      # Enable your new service!
      services =  {
        myNewService = {
          enable = true;
        };
      };
    }

Then you can build a vm for testing:

    $ NIXOS_CONFIG=`pwd`/vmtest.nix nixos-rebuild  -I nixos=/path/to/nixos/ build-vm

... and run it:

    $ ./result/bin/run-vmhost-vm

... work in progress ...

